# Конфигурационное управление

### Домашнее задание 4
#### Условие задания

Разработать ассемблер и интерпретатор для учебной виртуальной машины
(УВМ). Система команд УВМ представлена далее.
Для ассемблера необходимо разработать читаемое представление команд
УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к
которой задается из командной строки. Результатом работы ассемблера является
бинарный файл в виде последовательности байт, путь к которому задается из
командной строки. Дополнительный ключ командной строки задает путь к файлулогу, в котором хранятся ассемблированные инструкции в духе списков
“ключ=значение”, как в приведенных далее тестах.
Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ
и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон
также указывается из командной строки.
Форматом для файла-лога и файла-результата является json.

Необходимо реализовать приведенные тесты для всех команд, а также
написать и отладить тестовую программу

![{5C68FF05-BE51-4D3F-B935-F13CFF93A5AC}](https://github.com/user-attachments/assets/cd5fd9c7-7963-4c99-873a-42536dbf16d1)



![{5A1B1007-4C25-45B5-8BE9-C372B40461E7}](https://github.com/user-attachments/assets/e8f9239b-b692-4118-9efa-cf8d985036b5)



![{BD25046C-971C-4EF6-B577-71079DCD2C2F}](https://github.com/user-attachments/assets/a0b86c3f-8192-4d66-bd46-597fad003993)



![{3D98FF69-852C-455C-8647-07C3A9C899C2}](https://github.com/user-attachments/assets/b28acbcd-f230-4702-a9b4-6e4b46b51ef8)

Выполнить поэлементно операцию взятие остатка над двумя векторами длины 7. Результат записать во второй вектор.


### Тесты варианта

#### Загрузка константы
Тест (A=121, B=125, C=165):

0xF9, 0x7E, 0x29, 0x00, 0x00

![{89946F54-507B-47C9-BD72-98AAFB3E9C75}](https://github.com/user-attachments/assets/f34b758f-5d7d-4dbd-a7f1-52a57a3d5959)

#### Чтение значения из памяти
Тест (A=18, B=79, C=79):

0x92, 0xE7, 0x13, 0x00, 0x00

![{09E62220-5D11-42E5-AFA1-458DD93847EF}](https://github.com/user-attachments/assets/d1e4d174-e2dc-4b3e-810f-a538284b842e)

#### Запись значения в память
Тест (A=44, B=23, C=341):

0xAC, 0x4B, 0x55, 0x00, 0x00

![{4239C492-0AB3-4166-9C75-A2E3C4E29BAD}](https://github.com/user-attachments/assets/5e4a7c2e-5369-4295-a3cb-aedf5888428b)

#### Бинарная операция : взятие остатка
Тест (A=4, B=27, C=24):

0x84, 0x0D, 0x06, 0x00, 0x00

![{6921FDEB-B40D-4813-B449-A231701F2EB1}](https://github.com/user-attachments/assets/8d385578-a908-4280-b449-b51717c271cb)


## Основные функции ассемблера

### 1. pack_instruction(fields)

Эта функция отвечает за упаковку инструкции в бинарный формат. Основные этапы работы функции:

- Формирование инструкции: Функция принимает список полей, каждое из которых состоит из значения и его размера в битах. Инструкция формируется справа налево, где младшие биты добавляются первыми.
- Преобразование в байты: После формирования инструкции в виде целого числа, оно конвертируется в байтовый массив. Если итоговый размер меньше 5 байт, массив дополняется нулями слева.
- Переворот порядка байтов: Наконец, байты переворачиваются, чтобы соответствовать требованиям формата.

### 2. assemble(input_file, output_file, log_file)

Эта функция отвечает за ассемблирование кода из текстового файла в бинарный формат и создание лог-файла с описанием инструкций. Основные этапы работы:

- Чтение входного файла: Функция открывает текстовый файл, считывает команды и их аргументы.
- Обработка команд: В зависимости от команды (например, LOAD_CONST, READ_MEM, WRITE_MEM, MOD), функция определяет соответствующий опкод и формирует поля для упаковки.
- Упаковка инструкций: Каждая команда обрабатывается и упаковывается с помощью функции pack_instruction.
- Создание бинарного и лог-файлов: Упакованные инструкции добавляются в бинарный вывод, а также создается лог в формате JSON, который включает информацию о каждой инструкции, включая опкод, команду и аргументы.

## Запуск ассемблера 

python assembler.py <source_file> <bin_file> <log_file>

## Основные функции интерпретатора

#### 1. `interpret(binary_file, result_file, memory_range)`

Эта функция выполняет интерпретацию бинарного файла, содержащего инструкции, и записывает результаты выполнения в JSON файл. Она состоит из нескольких ключевых этапов:

- **Чтение бинарного файла**: Функция открывает бинарный файл и считывает его содержимое в переменную `data`. Это может быть массив байтов, представляющий инструкции.

- **Инициализация памяти и счетчика**: Создается простая модель памяти, представленная как список из 50 нулей. Переменная `program_counter` отслеживает текущую позицию в инструкции, а `log_data` и `execution_steps` используются для хранения логов выполнения и пошагового результата.

- **Цикл выполнения**: Основной цикл функции выполняет инструкции, пока не достигнет конца файла или не останется менее 5 байт. В каждом цикле:
  - Инструкция считывается из памяти.
  - Инструкция распаковывается в три компонента: `A`, `B` и `C`. 
  - Выполняются команды в зависимости от значения `A`:
    - **LOAD_CONST**: Загружает константу в регистр.
    - **READ_MEM**: Читает значение из памяти и записывает его в регистр.
    - **WRITE_MEM**: Записывает значение из регистра в память.
    - **MOD**: Выполняет операцию деления с остатком, проверяя делитель на ноль.

- **Логирование**: Каждое выполнение инструкции логируется в `log_data`, включая байтовое представление инструкции и значения `A`, `B`, `C`.

- **Формирование результата**: В конце работы функции формируется итоговый результат, который включает текущее состояние памяти в указанном диапазоне, лог выполнения и шаги выполнения инструкций.

- **Запись результата**: Результаты записываются в JSON файл, что позволяет легко проанализировать выполнение программы в дальнейшем.


### Содержимое исходного файла
LOAD_CONST 1 23
LOAD_CONST 2 11
LOAD_CONST 3 7
LOAD_CONST 4 5
LOAD_CONST 5 17
LOAD_CONST 6 25
LOAD_CONST 7 31
LOAD_CONST 9 14
LOAD_CONST 10 18
LOAD_CONST 11 3
LOAD_CONST 12 4
LOAD_CONST 13 5
LOAD_CONST 14 6
LOAD_CONST 15 3
MOD 1 9
MOD 2 10
MOD 3 11
MOD 4 12
MOD 5 13
MOD 6 14
MOD 7 15
WRITE_MEM 9 1
WRITE_MEM 10 2
WRITE_MEM 11 3
WRITE_MEM 12 4
WRITE_MEM 13 5
WRITE_MEM 14 6
WRITE_MEM 15 7

### Содержимое лог файла (фрагменты)

![{45BBF3B9-41CF-4E54-A700-9C7A132D62EC}](https://github.com/user-attachments/assets/56fd89d8-846f-4b74-abe9-d48f4ed8cbe1)


![{AC677721-83F6-498D-AD19-D9E65384B8D6}](https://github.com/user-attachments/assets/a00fd239-534b-4463-8263-eb0c2c514c95)


### Результат в файле json (фрагменты)

![{9E37DCC9-C23C-4E00-BC15-92ADFCDC5295}](https://github.com/user-attachments/assets/0aa014ad-0996-4ce5-a4b1-12dcd580655d)



![{D26896E0-15F9-4B27-A4D9-6104DBD37111}](https://github.com/user-attachments/assets/ba21e538-4cad-4a3d-8c90-2683a193dd65)



![{C6E0EF3D-9111-4366-AA85-A9563826FB83}](https://github.com/user-attachments/assets/a6022b7a-c9a7-41e7-b7cd-3cf98063302c)







